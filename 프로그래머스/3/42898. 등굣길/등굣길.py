# 등굣길
# 이런 경우의 수를 모두 구하는 문제면 보통 dfs나 bfs로 풀 수도 있지만 DP로 풀어야지 가능할 듯함.
# WHY? 대각선만 계산해봐도 1, 2, 6, 20 ... 기하급수적으로 늘어남, 최단경로 개수를 10억으로 나누라고 하면
# 그냥 개수 많이 나오나보다 생각해서.. dp로 풀기로 했음.

# 내가 푼 방식
# 1. 집이랑 학교는 고정위치. 그렇기 때문에 끝에는 경우의 수가 1밖에 안됨. 미리 배열만들고 1 채우기
# 2. 웅덩이는 아예 못 가니 경우의 수 0으로 넣기
# 3. 이중for문으로 배열마다 왼쪽+위의 경우의 수 더하기
# 이렇게 하면 간단하겠다 생각했는데 실수한 부분이 있었음. 보통 코테할 때 중요한 점은 이런 문제를 찾는 거라고 생각
# 웅덩이가 만약 테두리 중간에 있다면? 그럼 거기 뒤에도 다 0으로 수정해야 되는거였음.
# 그 코드를 추가해주니 정상 작동 되는 모습을 보임.
# 또 하나 어려웠던 점은 2차원 배열의 변수를 잘 설정해야 된다는 점.


def solution(m, n, puddles):
    answer = 0
    
    # -1로 배열 초기화
    dp = [[-1]*m for _ in range(n)]
    
    # 테두리 1로 채우기
    for i in range(m):
        dp[0][i] = 1
    for i in range(n):
        dp[i][0] = 1
    
    # 웅덩이 추가하기
    for i in puddles:
        if i[1]-1 == 0:
            for x in range(i[0]-1, m):
                dp[0][x] = 0
        elif i[0]-1 == 0:
            for y in range(i[1]-1, n):
                dp[y][0] = 0
        else:
            dp[i[1]-1][i[0]-1] = 0
        
    # dp로다가 각 배열 경우의 수 더해주기
    for i in range(1, m):
        for j in range(1, n):
            if dp[j][i] == 0:
                continue
            else:
                dp[j][i] = (dp[j-1][i] + dp[j][i-1])%1000000007
                               
    # 맨 마지막 학교부분 출력
    return dp[n-1][m-1]