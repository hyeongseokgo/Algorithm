# 내가 푼 방식, 여는 괄호를 1, 닫는 괄호를 0으로 이진화로 치환해서 풀어봄.
# 알고리즘은 0과 1개수가 똑같을 때 문자열을 확인해서 스택형식으로 앞에서 부터 1이면 +1
# 0이면 -1 해서 값이 음수가 나왔을 때는 break, 음수가 없었으면 chek += 1 해줘서 풀어봄
# 근데 너무 노가다라 n이 커지면 시간초과남. 망함.

#---------------------------------------------
# def solution(n):
#     i = 2**(n*2-1)
#     chek = 0
#     bul = True
    
#     while(1):
#         x = format(i, 'b')
        
#         if x.count('0') == x.count('1'):
#             stc = 0
#             for j in x:
#                 if j == '1':  stc +=1
#                 else:  stc -= 1
                
#                 if stc < 0:
#                     bul = False
#                     break    
#             if bul == True:
#                 chek += 1
        
        
#         i+= 2
#         bul = True
#         if i >=2**(n*2):
#             break

#     return chek
#--------------------------------------------

# 도저히 여기서 업그레이드를 시킬 수 없어서 질문하기에 있는 알고리즘으로 풀 예정
# 바로 다이나믹 프로그래밍(동적 계확법), 이건 작은 문제의 답을 저장하면서 굳이 또 계산을 하지 않는 방법
# 간단히 말해 피보나치 수열할 때 재귀함수 쓰면 컴터 터짐. 그때 f(0), f(1)값들은 따로 저장해서
# 이전 내용을 수행하지 않는 그런 프로그래밍 방법.
# 이걸 응용해서 n이 1, 2, 3 일때를 저장하면서 바로바로 계산할거임.
# n의 숫자는 괄호가 n개일 때 경우의 수다. 따라서 첫 괄호 안에 x개의 괄호의 경우의 수*밖에 y개의
# 괄호의 경우의 수를 곱해주는 식으로 해보자.


def solution(n):
    dp = [1, 1, 2]
    n_first = 2
    n_sum = 0
    while(n>2):
        y = 0
        x = n_first
        for i in range(n_first+1):
            n_sum += dp[x-i]*dp[y+i]
        dp.append(n_sum)
        n_first += 1
        n_sum = 0
        if n == n_first:
            break
    
    return dp[n]
    